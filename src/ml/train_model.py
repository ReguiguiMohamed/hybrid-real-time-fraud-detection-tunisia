# src/ml/train_model.py
import os
from pyspark.sql import SparkSession
from pyspark.sql.functions import col, when, lit
from xgboost.spark import SparkXGBClassifier
from pyspark.ml import Pipeline
from pyspark.ml.feature import VectorAssembler

class FraudModelTrainer:
    def __init__(self, silver_path="./data/parquet/silver_fraud_alerts"):
        self.spark = SparkSession.builder.appName("TunisianFraud-ModelTrainer").getOrCreate()
        self.silver_path = silver_path

    def load_and_enrich(self):
        # Read the Silver layer generated by your Day 4 stream
        df = self.spark.read.parquet(self.silver_path)
        
        # Gold Feature Engineering: D17 wallet-specific pressure checks
        gold_df = df.withColumn("is_smurfing", when(col("avg_amount").between(1400, 1500), 1).otherwise(0)) \
                    .withColumn("high_velocity_flag", when(col("v_count") > 5, 1).otherwise(0)) \
                    .withColumn("label", col("d17_risk").cast("int")) \
                    .na.fill(0)

        return gold_df

    def train(self):
        dataset = self.load_and_enrich()
        
        # Define the Feature Vector (Industrial standard for Spark ML)
        feature_cols = ["v_count", "g_dist", "avg_amount", "is_smurfing", "high_velocity_flag"]
        assembler = VectorAssembler(inputCols=feature_cols, outputCol="features", handleInvalid="keep")
        
        # XGBoost Spark Estimator (Standard since late 2024 for distributed Tabular AI)
        xgb = SparkXGBClassifier(
            featuresCol="features",
            labelCol="label",
            max_depth=6,
            n_estimators=100,
            learning_rate=0.1
        )
        
        pipeline = Pipeline(stages=[assembler, xgb])
        model = pipeline.fit(dataset)
        
        # Persistent 'Brain' - Saved for Day 5 Iteration 2
        model.write().overwrite().save("models/fraud_xgb_v1")
        print("âœ… Gold Model (XGBoost) trained and saved to /models/fraud_xgb_v1")

if __name__ == "__main__":
    trainer = FraudModelTrainer()
    trainer.train()